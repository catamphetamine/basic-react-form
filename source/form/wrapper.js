import { Component, createElement } from 'react'

// Build an outer component
// with the only purpose
// to expose instance API methods
export default function build_outer_component(Connected_form, options)
{
	const wrapper = class ReduxForm extends Component
	{
		constructor()
		{
			super()

			this.get_form_id = this.get_form_id.bind(this)

			this.ref    = this.ref.bind(this)
			this.focus  = this.focus.bind(this)
			this.scroll = this.scroll.bind(this)
			this.clear  = this.clear.bind(this)
			this.set    = this.set.bind(this)
		}

		ref()
		{
			return this.refs.connected_form.getWrappedInstance().refs.user_form
		}

		focus(field)
		{
			return this.refs.connected_form.getWrappedInstance().focus(field)
		}

		scroll(field)
		{
			return this.refs.connected_form.getWrappedInstance().scroll_to_field(field)
		}

		clear(field, error)
		{
			return this.refs.connected_form.getWrappedInstance().clear_field(field, error)
		}

		set(field, value, error)
		{
			return this.refs.connected_form.getWrappedInstance().set_field(field, value, error)
		}

		// // For tests
		// get wrappedInstance()
		// {
		// 	return this.refs.connected_form.getWrappedInstance().refs.wrapped
		// }

		// Autogenerates form id and keeps returning it from then on.
		// The form id is stored in `this.form_id` instance variable.
		// This way every time a form is mounted
		// (if it's not reused by React in which case `key`s will do the trick)
		// a new form id is generated.
		get_form_id(state, props, options)
		{
			// If this function is called a subsequent time
			// then return an already autogenerated form id.
			if (!this.form_id)
			{
				this.form_id = get_form_id(state, props, options)
			}

			return this.form_id
		}

		render()
		{
			return createElement(Connected_form,
			{
				...this.props,
				ref         : 'connected_form',
				get_form_id : this.get_form_id
			})
		}
	}

	// Proxy some instance methods (if specified)
	if (options.methods)
	{
		for (const method of options.methods)
		{
			if (wrapper.prototype[method])
			{
				console.error(`Form method "${method}" is already defined`)
			}

			wrapper.prototype[method] = function()
			{
				this.ref()[method].apply(this, arguments)
			}
		}
	}

	return wrapper
}

// Get form id
function get_form_id(state, props, options)
{
	// If `id` was set in the decorator options
	if (options.id)
	{
		// `id` can be either a String or a Function of `props`
		return typeof options.id === 'string' ? options.id : options.id(props)
	}

	// camelCase aliasing for `formId` property on the decorated component
	if (props.form_id || props.formId)
	{
		return props.form_id || props.formId
	}

	// Autogenerate @Form() `id`.
	return autogenerate_form_id(state.form)
}

// Autogenerate @Form() `id`
//
// `@connect()` will be called in `Form` constructor,
// and form is registered in `componentWillMount` of a `Form`,
// which means that theoretically if two forms
// were created side-by-side in a parent component
// and then mounted inside it, then there potentially
// could be an ID collision, but that's very unlikely.
//
function autogenerate_form_id(forms)
{
	// Generate a random form ID.
	// Since there's no multiply-and-floor involved here
	// it is considered really random (much safe, such PRNG)
	// https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d
	const id = String(Math.random()).slice(2)

	// If this form ID is already taken,
	// then try another one.
	if (forms[id])
	{
		return autogenerate_form_id(forms)
	}

	return id
}